# import the necessary packages
import numpy as np
import cv2

def order_points(pts):
    # инициализируем список координат, которые будут упорядочены
	# таким образом, чтобы первая запись в списке была верхней левой,
	# вторая запись - справа вверху, третья -
	# внизу справа, а четвертый - внизу слева
	
    rect = np.zeros((4, 2), dtype = "float32" )
	
    # верхняя левая точка будет иметь наименьшую сумму, тогда как
	# нижняя правая точка будет иметь наибольшую сумму
	
    s = pts.sum(axis = 1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
	
    # теперь вычисляем разницу между точками,
	# верхняя правая точка будет иметь наименьшую разницу,
	# тогда как в левом нижнем углу разница будет наибольшей
	
    diff = np.diff(pts, axis = 1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
	
	# вернуть упорядоченные координаты
    return rect

def four_point_transform(image, pts): 
	# получить последовательный порядок точек и распаковать их
	# индивидуально
	
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
	
    # вычислить ширину нового изображения, которое будет
	# максимальное расстояние между нижним правым и нижним левым углами
	# x-координаты или x-координаты верхнего правого и верхнего левого угла
	
    widthA = np.sqrt(((br[ 0 ] - bl[ 0 ]) ** 2 ) + ((br[ 1 ] - bl[ 1 ]) ** 2))
    widthB = np.sqrt(((tr[ 0 ] - tl[ 0 ]) ** 2 ) + ((tr[ 1 ] - tl[ 1 ]) ** 2))
    maxWidth = max(int( widthA ) ,int( widthB ))

    # вычислить высоту нового изображения, которая будет
	# максимальное расстояние между верхним правым и нижним правым углами
	# y-координаты или y-координаты верхнего левого и нижнего левого угла
	
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # теперь, когда у нас есть размеры нового изображения, построим
	# набор точек назначения для получения "вида с высоты птичьего полета",
	# (т.е. вид сверху вниз) изображения, снова указав точки
	# в верхнем левом, верхнем правом, нижнем правом и нижнем левом углах
	
    dst = np.array([
		[0, 0],
		[maxWidth - 1, 0],
		[maxWidth - 1, maxHeight - 1],
		[0, maxHeight - 1]], dtype = "float32")

    # вычислить матрицу перспективного преобразования и затем применить ее
	
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))

    # вернуть искаженное изображение
    return warped

